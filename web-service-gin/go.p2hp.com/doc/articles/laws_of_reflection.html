<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>



  
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#00add8">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons">
<link rel="stylesheet" href="../../css/styles.css">

<link rel="alternate" title="The Go Blog" type="application/atom+xml" href="https://go.p2hp.com/blog/feed.atom">

  
  
  
<script src="../../go.dev/js/site.js"></script>
<meta name="og:url" content="https://go.dev/blog/laws-of-reflection">
<meta name="og:title" content="The Laws of Reflection - The Go Programming Language">
<title>The Laws of Reflection - Go中文网 Go语言中文网 golang</title>

 
<meta name="og:description" content="Go中文网 Go语言中文网 golang ;Go 是一种开源编程语言，可以轻松构建简单、可靠和高效的软件">
 
<meta name="description" content="Go中文网 Go语言中文网 golang ;Go 是一种开源编程语言，可以轻松构建简单、可靠和高效的软件.">

 
<meta name="og:image" content="https://go.dev/doc/gopher/gopher5logo.jpg">
<meta name="twitter:image" content="https://go.dev/doc/gopher/runningsquare.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@golang">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4638549725433695" crossorigin="anonymous"></script><script src="https://www.p2hp.com/tj.js"></script></head>
<body class="Site">
  

  


<header class="Site-header js-siteHeader">
  <div class="Header Header--dark">
    <nav class="Header-nav">
      <a href="https://go.p2hp.com/" title="Go中文网">
        <img
          class="js-headerLogo Header-logo"
          src="../../go.dev/images/go-logo-white.svg"
          alt="Go">
      </a>
      <div class="Header-rightContent">
        <ul class="Header-menu">
          <li class="Header-menuItem ">
            <a href="https://go.p2hp.com/solutions/" target="">为什么用Go</a>
          </li>
          <li class="Header-menuItem ">
            <a href="https://go.p2hp.com/learn/" target="">快速开始</a>
          </li>
          <li class="Header-menuItem ">
            <a href="../index.html" target="">文档</a>
          </li>
          <li class="Header-menuItem ">
            <a href="https://pkg.go.dev" target="_blank">包</a>
          </li>
          <li class="Header-menuItem ">
            <a href="https://go.p2hp.com/play/" target="">在线运行</a>
          </li>
          <li class="Header-menuItem  Header-menuItem--active">
            <a href="https://go.p2hp.com/blog/" target="">博客</a>
          </li>
        </ul>
        <button class="Header-navOpen js-headerMenuButton Header-navOpen--white" aria-label="Open navigation.">
        </button>
      </div>
    </nav>
    
  </div>
</header>
<aside class="NavigationDrawer js-header">
  <nav class="NavigationDrawer-nav">
    <div class="NavigationDrawer-header">
      <a href="https://go.p2hp.com/">
        <img class="NavigationDrawer-logo" src="../../go.dev/images/go-logo-blue.svg" alt="Go.">
      </a>
    </div>
    <ul class="NavigationDrawer-list">
        <li class="NavigationDrawer-listItem ">
          <a href="https://go.p2hp.com/solutions/">为什么用Go</a>
        </li>
        <li class="NavigationDrawer-listItem ">
          <a href="https://go.p2hp.com/learn/">快速开始</a>
        </li>
        <li class="NavigationDrawer-listItem ">
          <a href="../index.html">文档</a>
        </li>
        <li class="NavigationDrawer-listItem ">
          <a href="https://pkg.go.dev">包</a>
        </li>
        <li class="NavigationDrawer-listItem ">
          <a href="https://go.p2hp.com/play/">在线运行</a>
        </li>
        <li class="NavigationDrawer-listItem  NavigationDrawer-listItem--active">
          <a href="https://go.p2hp.com/blog/">博客</a>
        </li>
    </ul>
  </nav>
</aside>
<div class="NavigationDrawer-scrim js-scrim" role="presentation"></div>
<main class="SiteContent SiteContent--default">
  
<div id="blog"><div id="content">
  <div id="content">

    <div class="Article" data-slug="/blog/laws-of-reflection">
    
    <h1 class="small"><a href="https://go.p2hp.com/blog/">The Go Blog</a></h1>
    

    <h1>The Laws of Reflection</h1>
      
      <p class="author">
      Rob Pike<br>
      6 September 2011
      </p>
      
      <h2 id="introduction">Introduction</h2>
<p>Reflection in computing is the ability of a program to examine its own structure,
particularly through types;
it&rsquo;s a form of metaprogramming.
It&rsquo;s also a great source of confusion.</p>
<p>In this article we attempt to clarify things by explaining how reflection works in Go.
Each language&rsquo;s reflection model is different (and many languages don&rsquo;t support it at all),
but this article is about Go, so for the rest of this article the word &ldquo;reflection&rdquo;
should be taken to mean &ldquo;reflection in Go&rdquo;.</p>
<p>Note added January 2022: This blog post was written in 2011 and predates
parametric polymorphism (a.k.a. generics) in Go.
Although nothing important in the article has become incorrect as as a result
of that development in the language,
it has been tweaked in a few places to avoid
confusing someone familiar with modern Go.</p>
<h2 id="types-and-interfaces">Types and interfaces</h2>
<p>Because reflection builds on the type system, let&rsquo;s start with a refresher about types in Go.</p>
<p>Go is statically typed. Every variable has a static type,
that is, exactly one type known and fixed at compile time:
<code>int</code>, <code>float32</code>, <code>*MyType</code>, <code>[]byte</code>, and so on. If we declare</p>
<pre><code>type MyInt int

var i int
var j MyInt
</code></pre>
<p>then <code>i</code> has type <code>int</code> and <code>j</code> has type <code>MyInt</code>.
The variables <code>i</code> and <code>j</code> have distinct static types and,
although they have the same underlying type,
they cannot be assigned to one another without a conversion.</p>
<p>One important category of type is interface types,
which represent fixed sets of methods.
(When discussing reflection, we can ignore the use of
interface definitions as constraints within polymorphic code.)
An interface variable can store any concrete (non-interface) value as long
as that value implements the interface&rsquo;s methods.
A well-known pair of examples is <code>io.Reader</code> and <code>io.Writer</code>,
the types <code>Reader</code> and <code>Writer</code> from the <a href="https://go.p2hp.com/pkg/io/">io package</a>:</p>
<pre><code>// Reader is the interface that wraps the basic Read method.
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<p>Any type that implements a <code>Read</code> (or <code>Write</code>) method with this signature
is said to implement <code>io.Reader</code> (or <code>io.Writer</code>).
For the purposes of this discussion, that means that a variable of type
<code>io.Reader</code> can hold any value whose type has a <code>Read</code> method:</p>
<pre><code>var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on
</code></pre>
<p>It&rsquo;s important to be clear that whatever concrete value <code>r</code> may hold,
<code>r</code>&rsquo;s type is always <code>io.Reader</code>:
Go is statically typed and the static type of <code>r</code> is <code>io.Reader</code>.</p>
<p>An extremely important example of an interface type is the empty interface:</p>
<pre><code>interface{}
</code></pre>
<p>or its equivalent alias,</p>
<pre><code>any
</code></pre>
<p>It represents the empty set of methods and is satisfied by any value at all, since every value has zero or more methods.</p>
<p>Some people say that Go&rsquo;s interfaces are dynamically typed,
but that is misleading.
They are statically typed: a variable of interface type always has the same static type,
and even though at run time the value stored in the interface variable may change type,
that value will always satisfy the interface.</p>
<p>We need to be precise about all this because reflection and interfaces are closely related.</p>
<h2 id="the-representation-of-an-interface">The representation of an interface</h2>
<p>Russ Cox has written a <a href="https://research.swtch.com/2009/12/go-data-structures-interfaces.html" rel="noreferrer" target="_blank"> detailed blog post</a>
about the representation of interface values in Go.
It&rsquo;s not necessary to repeat the full story here,
but a simplified summary is in order.</p>
<p>A variable of interface type stores a pair:
the concrete value assigned to the variable,
and that value&rsquo;s type descriptor.
To be more precise, the value is the underlying concrete data item that
implements the interface and the type describes the full type of that item. For instance, after</p>
<pre><code>var r io.Reader
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
</code></pre>
<p><code>r</code> contains, schematically, the (value, type) pair,
(<code>tty</code>, <code>*os.File</code>).
Notice that the type <code>*os.File</code> implements methods other than <code>Read</code>;
even though the interface value provides access only to the <code>Read</code> method,
the value inside carries all the type information about that value.
That&rsquo;s why we can do things like this:</p>
<pre><code>var w io.Writer
w = r.(io.Writer)
</code></pre>
<p>The expression in this assignment is a type assertion;
what it asserts is that the item inside <code>r</code> also implements <code>io.Writer</code>,
and so we can assign it to <code>w</code>.
After the assignment, <code>w</code> will contain the pair (<code>tty</code>, <code>*os.File</code>).
That&rsquo;s the same pair as was held in <code>r</code>. The static type of the interface
determines what methods may be invoked with an interface variable,
even though the concrete value inside may have a larger set of methods.</p>
<p>Continuing, we can do this:</p>
<pre><code>var empty interface{}
empty = w
</code></pre>
<p>and our empty interface value <code>empty</code> will again contain that same pair,
(<code>tty</code>, <code>*os.File</code>).
That&rsquo;s handy: an empty interface can hold any value and contains all the
information we could ever need about that value.</p>
<p>(We don&rsquo;t need a type assertion here because it&rsquo;s known statically that
<code>w</code> satisfies the empty interface.
In the example where we moved a value from a <code>Reader</code> to a <code>Writer</code>,
we needed to be explicit and use a type assertion because <code>Writer</code>&rsquo;s methods
are not a subset of <code>Reader</code>&rsquo;s.)</p>
<p>One important detail is that the pair inside an interface variable always has the form (value,
concrete type) and cannot have the form (value, interface type).
Interfaces do not hold interface values.</p>
<p>Now we&rsquo;re ready to reflect.</p>
<h2 id="the-first-law-of-reflection">The first law of reflection</h2>
<h2 id="1-reflection-goes-from-interface-value-to-reflection-object">1. Reflection goes from interface value to reflection object.</h2>
<p>At the basic level, reflection is just a mechanism to examine the type and
value pair stored inside an interface variable.
To get started, there are two types we need to know about in <a href="https://go.p2hp.com/pkg/reflect/">package reflect</a>:
<a href="https://go.p2hp.com/pkg/reflect/#Type">Type</a> and <a href="https://go.p2hp.com/pkg/reflect/#Value">Value</a>.
Those two types give access to the contents of an interface variable,
and two simple functions, called <code>reflect.TypeOf</code> and <code>reflect.ValueOf</code>,
retrieve <code>reflect.Type</code> and <code>reflect.Value</code> pieces out of an interface value.
(Also, from a <code>reflect.Value</code> it&rsquo;s easy to get to the corresponding <code>reflect.Type</code>,
but let&rsquo;s keep the <code>Value</code> and <code>Type</code> concepts separate for now.)</p>
<p>Let&rsquo;s start with <code>TypeOf</code>:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    var x float64 = 3.4
    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
}
</code></pre>
<p>This program prints</p>
<pre><code>type: float64
</code></pre>
<p>You might be wondering where the interface is here,
since the program looks like it&rsquo;s passing the <code>float64</code> variable <code>x</code>,
not an interface value, to <code>reflect.TypeOf</code>.
But it&rsquo;s there; as <a href="https://go.p2hp.com/pkg/reflect/#TypeOf">godoc reports</a>,
the signature of <code>reflect.TypeOf</code> includes an empty interface:</p>
<pre><code>// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
</code></pre>
<p>When we call <code>reflect.TypeOf(x)</code>, <code>x</code> is first stored in an empty interface,
which is then passed as the argument;
<code>reflect.TypeOf</code> unpacks that empty interface to recover the type information.</p>
<p>The <code>reflect.ValueOf</code> function, of course,
recovers the value (from here on we&rsquo;ll elide the boilerplate and focus just
on the executable code):</p>
<pre><code>var x float64 = 3.4
fmt.Println(&quot;value:&quot;, reflect.ValueOf(x).String())
</code></pre>
<p>prints</p>
<pre><code>value: &lt;float64 Value&gt;
</code></pre>
<p>(We call the <code>String</code> method explicitly because by default the <code>fmt</code> package
digs into a <code>reflect.Value</code> to show the concrete value inside.
The <code>String</code> method does not.)</p>
<p>Both <code>reflect.Type</code> and <code>reflect.Value</code> have lots of methods to let us examine
and manipulate them.
One important example is that <code>Value</code> has a <code>Type</code> method that returns the
<code>Type</code> of a <code>reflect.Value</code>.
Another is that both <code>Type</code> and <code>Value</code> have a <code>Kind</code> method that returns
a constant indicating what sort of item is stored:
<code>Uint</code>, <code>Float64</code>, <code>Slice</code>, and so on.
Also methods on <code>Value</code> with names like <code>Int</code> and <code>Float</code> let us grab values
(as <code>int64</code> and <code>float64</code>) stored inside:</p>
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())
fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
fmt.Println(&quot;value:&quot;, v.Float())
</code></pre>
<p>prints</p>
<pre><code>type: float64
kind is float64: true
value: 3.4
</code></pre>
<p>There are also methods like <code>SetInt</code> and <code>SetFloat</code> but to use them we need
to understand settability,
the subject of the third law of reflection, discussed below.</p>
<p>The reflection library has a couple of properties worth singling out.
First, to keep the API simple, the &ldquo;getter&rdquo; and &ldquo;setter&rdquo; methods of <code>Value</code>
operate on the largest type that can hold the value:
<code>int64</code> for all the signed integers, for instance.
That is, the <code>Int</code> method of <code>Value</code> returns an <code>int64</code> and the <code>SetInt</code>
value takes an <code>int64</code>;
it may be necessary to convert to the actual type involved:</p>
<pre><code>var x uint8 = 'x'
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())                            // uint8.
fmt.Println(&quot;kind is uint8: &quot;, v.Kind() == reflect.Uint8) // true.
x = uint8(v.Uint())                                       // v.Uint returns a uint64.
</code></pre>
<p>The second property is that the <code>Kind</code> of a reflection object describes
the underlying type,
not the static type.
If a reflection object contains a value of a user-defined integer type, as in</p>
<pre><code>type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
</code></pre>
<p>the <code>Kind</code> of <code>v</code> is still <code>reflect.Int</code>,
even though the static type of <code>x</code> is <code>MyInt</code>, not <code>int</code>.
In other words, the <code>Kind</code> cannot discriminate an <code>int</code> from a <code>MyInt</code> even
though the <code>Type</code> can.</p>
<h2 id="the-second-law-of-reflection">The second law of reflection</h2>
<h2 id="2-reflection-goes-from-reflection-object-to-interface-value">2. Reflection goes from reflection object to interface value.</h2>
<p>Like physical reflection, reflection in Go generates its own inverse.</p>
<p>Given a <code>reflect.Value</code> we can recover an interface value using the <code>Interface</code> method;
in effect the method packs the type and value information back into an interface
representation and returns the result:</p>
<pre><code>// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
</code></pre>
<p>As a consequence we can say</p>
<pre><code>y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
</code></pre>
<p>to print the <code>float64</code> value represented by the reflection object <code>v</code>.</p>
<p>We can do even better, though. The arguments to <code>fmt.Println</code>,
<code>fmt.Printf</code> and so on are all passed as empty interface values,
which are then unpacked by the <code>fmt</code> package internally just as we have
been doing in the previous examples.
Therefore all it takes to print the contents of a <code>reflect.Value</code> correctly
is to pass the result of the <code>Interface</code> method to the formatted print routine:</p>
<pre><code>fmt.Println(v.Interface())
</code></pre>
<p>(Since the this article was first written, a change was made to the <code>fmt</code>
package so that it automatically unpacks a <code>reflect.Value</code> like this, so
we could just say</p>
<pre><code>fmt.Println(v)
</code></pre>
<p>for the same result, but for clarity we&rsquo;ll keep the <code>.Interface()</code> calls
here.)</p>
<p>Since our value is a <code>float64</code>,
we can even use a floating-point format if we want:</p>
<pre><code>fmt.Printf(&quot;value is %7.1e\n&quot;, v.Interface())
</code></pre>
<p>and get in this case</p>
<pre><code>3.4e+00
</code></pre>
<p>Again, there&rsquo;s no need to type-assert the result of <code>v.Interface()</code> to <code>float64</code>;
the empty interface value has the concrete value&rsquo;s type information inside
and <code>Printf</code> will recover it.</p>
<p>In short, the <code>Interface</code> method is the inverse of the <code>ValueOf</code> function,
except that its result is always of static type <code>interface{}</code>.</p>
<p>Reiterating: Reflection goes from interface values to reflection objects and back again.</p>
<h2 id="the-third-law-of-reflection">The third law of reflection</h2>
<h2 id="3-to-modify-a-reflection-object-the-value-must-be-settable">3. To modify a reflection object, the value must be settable.</h2>
<p>The third law is the most subtle and confusing, but it&rsquo;s easy enough to understand if we start from first principles.</p>
<p>Here is some code that does not work, but is worth studying.</p>
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
</code></pre>
<p>If you run this code, it will panic with the cryptic message</p>
<pre><code>panic: reflect.Value.SetFloat using unaddressable value
</code></pre>
<p>The problem is not that the value <code>7.1</code> is not addressable;
it&rsquo;s that <code>v</code> is not settable.
Settability is a property of a reflection <code>Value</code>,
and not all reflection <code>Values</code> have it.</p>
<p>The <code>CanSet</code> method of <code>Value</code> reports the settability of a <code>Value</code>; in our case,</p>
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;settability of v:&quot;, v.CanSet())
</code></pre>
<p>prints</p>
<pre><code>settability of v: false
</code></pre>
<p>It is an error to call a <code>Set</code> method on an non-settable <code>Value</code>. But what is settability?</p>
<p>Settability is a bit like addressability, but stricter.
It&rsquo;s the property that a reflection object can modify the actual storage
that was used to create the reflection object.
Settability is determined by whether the reflection object holds the original item. When we say</p>
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
</code></pre>
<p>we pass a copy of <code>x</code> to <code>reflect.ValueOf</code>,
so the interface value created as the argument to <code>reflect.ValueOf</code> is a
copy of <code>x</code>, not <code>x</code> itself.
Thus, if the statement</p>
<pre><code>v.SetFloat(7.1)
</code></pre>
<p>were allowed to succeed, it would not update <code>x</code>,
even though <code>v</code> looks like it was created from <code>x</code>.
Instead, it would update the copy of <code>x</code> stored inside the reflection value
and <code>x</code> itself would be unaffected.
That would be confusing and useless, so it is illegal,
and settability is the property used to avoid this issue.</p>
<p>If this seems bizarre, it&rsquo;s not. It&rsquo;s actually a familiar situation in unusual garb.
Think of passing <code>x</code> to a function:</p>
<pre><code>f(x)
</code></pre>
<p>We would not expect <code>f</code> to be able to modify <code>x</code> because we passed a copy
of <code>x</code>&rsquo;s value, not <code>x</code> itself.
If we want <code>f</code> to modify <code>x</code> directly we must pass our function the address
of <code>x</code> (that is, a pointer to <code>x</code>):</p>
<pre><code>f(&amp;x)
</code></pre>
<p>This is straightforward and familiar, and reflection works the same way.
If we want to modify <code>x</code> by reflection, we must give the reflection library
a pointer to the value we want to modify.</p>
<p>Let&rsquo;s do that. First we initialize <code>x</code> as usual and then create a reflection value that points to it, called <code>p</code>.</p>
<pre><code>var x float64 = 3.4
p := reflect.ValueOf(&amp;x) // Note: take the address of x.
fmt.Println(&quot;type of p:&quot;, p.Type())
fmt.Println(&quot;settability of p:&quot;, p.CanSet())
</code></pre>
<p>The output so far is</p>
<pre><code>type of p: *float64
settability of p: false
</code></pre>
<p>The reflection object <code>p</code> isn&rsquo;t settable,
but it&rsquo;s not <code>p</code> we want to set, it&rsquo;s (in effect) <code>*p</code>.
To get to what <code>p</code> points to, we call the <code>Elem</code> method of <code>Value</code>,
which indirects through the pointer, and save the result in a reflection <code>Value</code> called <code>v</code>:</p>
<pre><code>v := p.Elem()
fmt.Println(&quot;settability of v:&quot;, v.CanSet())
</code></pre>
<p>Now <code>v</code> is a settable reflection object, as the output demonstrates,</p>
<pre><code>settability of v: true
</code></pre>
<p>and since it represents <code>x</code>, we are finally able to use <code>v.SetFloat</code> to modify the value of <code>x</code>:</p>
<pre><code>v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
</code></pre>
<p>The output, as expected, is</p>
<pre><code>7.1
7.1
</code></pre>
<p>Reflection can be hard to understand but it&rsquo;s doing exactly what the language does,
albeit through reflection <code>Types</code> and <code>Values</code> that can disguise what&rsquo;s going on.
Just keep in mind that reflection Values need the address of something in
order to modify what they represent.</p>
<h2 id="structs">Structs</h2>
<p>In our previous example <code>v</code> wasn&rsquo;t a pointer itself,
it was just derived from one.
A common way for this situation to arise is when using reflection to modify
the fields of a structure.
As long as we have the address of the structure,
we can modify its fields.</p>
<p>Here&rsquo;s a simple example that analyzes a struct value, <code>t</code>.
We create the reflection object with the address of the struct because we&rsquo;ll
want to modify it later.
Then we set <code>typeOfT</code> to its type and iterate over the fields using straightforward
method calls (see <a href="https://go.p2hp.com/pkg/reflect/">package reflect</a> for details).
Note that we extract the names of the fields from the struct type,
but the fields themselves are regular <code>reflect.Value</code> objects.</p>
<pre><code>type T struct {
    A int
    B string
}
t := T{23, &quot;skidoo&quot;}
s := reflect.ValueOf(&amp;t).Elem()
typeOfT := s.Type()
for i := 0; i &lt; s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
</code></pre>
<p>The output of this program is</p>
<pre><code>0: A int = 23
1: B string = skidoo
</code></pre>
<p>There&rsquo;s one more point about settability introduced in passing here:
the field names of <code>T</code> are upper case (exported) because only exported fields
of a struct are settable.</p>
<p>Because <code>s</code> contains a settable reflection object, we can modify the fields of the structure.</p>
<pre><code>s.Field(0).SetInt(77)
s.Field(1).SetString(&quot;Sunset Strip&quot;)
fmt.Println(&quot;t is now&quot;, t)
</code></pre>
<p>And here&rsquo;s the result:</p>
<pre><code>t is now {77 Sunset Strip}
</code></pre>
<p>If we modified the program so that <code>s</code> was created from <code>t</code>,
not <code>&amp;t</code>, the calls to <code>SetInt</code> and <code>SetString</code> would fail as the fields
of <code>t</code> would not be settable.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Here again are the laws of reflection:</p>
<ul>
<li>
<p>Reflection goes from interface value to reflection object.</p>
</li>
<li>
<p>Reflection goes from reflection object to interface value.</p>
</li>
<li>
<p>To modify a reflection object, the value must be settable.</p>
</li>
</ul>
<p>Once you understand these laws reflection in Go becomes much easier to use,
although it remains subtle.
It&rsquo;s a powerful tool that should be used with care and avoided unless strictly necessary.</p>
<p>There&rsquo;s plenty more to reflection that we haven&rsquo;t covered — sending and
receiving on channels,
allocating memory, using slices and maps,
calling methods and functions — but this post is long enough.
We&rsquo;ll cover some of those topics in a later article.</p>

    </div>

    
    <div class="Article prevnext">
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <p>
        
          
            <b>Next article: </b><a href="https://go.p2hp.com/blog/image">The Go image package</a><br>
          
        
        
          
            <b>Previous article: </b><a href="https://go.p2hp.com/blog/sydney-gtug">Two Go Talks: &#34;Lexical Scanning in Go&#34; and &#34;Cuddle: an App Engine Demo&#34;</a><br>
          
        
        <b><a href="https://go.p2hp.com/blog/all">Blog Index</a></b>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    </div>
    

  </div>
</div>

<script src="../../go.dev/js/jquery.js"></script>
<script src="../../go.dev/js/playground.js"></script>
<script src="https://go.p2hp.com/go.dev/js/play.js"></script>
<script src="../../go.dev/js/godocs.js"></script>

</main>
<footer class="Site-footer">
  <div class="Footer">
    <div class="Container">
      <div class="Footer-links">
          <div class="Footer-linkColumn">
            <a href="https://go.p2hp.com/solutions/"  target="" class="Footer-link Footer-link--primary">
              为什么用Go
            </a>
              <a href="https://go.p2hp.com/solutions/#use-cases"  target="" class="Footer-link">
                用例
              </a>
              <a href="https://go.p2hp.com/solutions/#case-studies"  target="" class="Footer-link">
                实例探究
              </a>
          </div>
          <div class="Footer-linkColumn">
            <a href="https://go.p2hp.com/learn/"  target="" class="Footer-link Footer-link--primary">
              快速开始
            </a>
              <a href="https://go.p2hp.com/play"  target="" class="Footer-link">
                在线运行
              </a>
              <a href="https://go.p2hp.com/tour/"  target="" class="Footer-link">
                边学边练
              </a>
              <a href="https://stackoverflow.com/questions/tagged/go?tab=Newest"  target="_blank" class="Footer-link">
                Stack Overflow
              </a>
              <a href="https://go.p2hp.com/help/"  target="" class="Footer-link">
                帮助
              </a>
          </div>
          <div class="Footer-linkColumn">
            <a href="https://pkg.go.dev"  target="_blank" class="Footer-link Footer-link--primary">
              包
            </a>
              <a href="https://go.p2hp.com/pkg/"  target="_blank" class="Footer-link">
                标准库
              </a>
          </div>
          <div class="Footer-linkColumn">
            <a href="https://go.p2hp.com/project"  target="" class="Footer-link Footer-link--primary">
              关于
            </a>
              <a href="https://go.p2hp.com/dl/"  target="" class="Footer-link">
                下载
              </a>
              <a href="https://go.p2hp.com/blog/"  target="" class="Footer-link">
                博客
              </a>
              <a href="https://github.com/golang/go/issues"  target="_blank" class="Footer-link">
                问题追踪
              </a>
              <a href="../devel/release.html"  target="" class="Footer-link">
                发行说明
              </a>
              <a href="https://go.p2hp.com/blog/go-brand"  target="_blank" class="Footer-link">
                品牌指南
              </a>
              <a href="https://go.p2hp.com/conduct"  target="" class="Footer-link">
                行为守则
              </a>
          </div>
          <div class="Footer-linkColumn">
            <a href="laws_of_reflection.html"  target="_blank" class="Footer-link Footer-link--primary">
              连接
            </a>
              <a href="https://github.com/golang"  target="_blank" class="Footer-link">
                GitHub
              </a>
              <a href="https://invite.slack.golangbridge.org/"  target="_blank" class="Footer-link">
                Slack
              </a>
              <a href="https://www.meetup.com/pro/go"  target="_blank" class="Footer-link">
                Meetup
              </a>
              <a href="https://golangweekly.com/"  target="_blank" class="Footer-link">
                Golang Weekly
              </a>
          </div>
      </div>
    </div>
  </div>
  <div class="Footer">
    <div class="Container Container--fullBleed">
      <div class="Footer-bottom">
        <img class="Footer-gopher" src="../../go.dev/images/gophers/pilot-bust.svg" alt="The Go Gopher">
        <ul class="Footer-listRow">
          <li class="Footer-listItem">
            <a href="https://go.p2hp.com/copyright">版权</a>
          </li>
          <li class="Footer-listItem">
            <a href="https://go.p2hp.com/tos">服务条款</a>
          </li>
          <li class="Footer-listItem">
            <a href="https://www.p2hp.com/privacy-policy.php"
              target="_blank"
              rel="noopener">
              隐私政策
            </a>
            </li>
            <li class="Footer-listItem">
            <a href="https://go.p2hp.com/sitemap"
              target="_blank"
              rel="noopener">
              网站地图
            </a>
            </li>
          
          <li class="Footer-listItem">
            <a
              href="https://go.p2hp.com/lianxi"
              target="_blank"
              >
              联系本站
            </a>
          </li>
          <li class="Footer-listItem">
            
              <a href="https://go.p2hp.com">Go中文网</a>版权所有 © 2021-2023
             
          </li>
          <li class="Footer-listItem">
            
              由 Lenix 建立和翻译 <span style="color: #e27575;font-size: 14px;">❤</span>
             
          </li>
          <li class="Footer-listItem">
            
              请按Ctrl+D试试
             
          </li>
          <li class="Footer-listItem go-Footer-listItem">
            <button class="go-Button go-Button--text go-Footer-toggleTheme js-toggleTheme" aria-label="Toggle theme">
              <img
                data-value="auto"
                class="go-Icon go-Icon--inverted"
                height="24"
                width="24"
                src="../../go.dev/images/icons/brightness_6_gm_grey_24dp.svg"
                alt="System theme">
              <img
                data-value="dark"
                class="go-Icon go-Icon--inverted"
                height="24"
                width="24"
                src="../../go.dev/images/icons/brightness_2_gm_grey_24dp.svg"
                alt="Dark theme">
              <img
                data-value="light"
                class="go-Icon go-Icon--inverted"
                height="24"
                width="24"
                src="../../go.dev/images/icons/light_mode_gm_grey_24dp.svg"
                alt="Light theme">
            </button>
          </li>
        </ul>
        <a class="Footer-googleLogo" target="_blank" href="https://go.p2hp.com" rel="noopener">
          <img class="Footer-googleLogoImg" src="../../go.dev/images/go-white.png" alt="go中文网 logo">
        </a>
      </div>
    </div>
  </div>
  <script src="../../go.dev/js/jquery.js"></script>
  <script src="../../go.dev/js/carousels.js"></script>
  <script src="../../go.dev/js/searchBox.js"></script>
  <script src="../../go.dev/js/misc.js"></script>
  <script src="../../go.dev/js/hats.js"></script>
  <script src="../../go.dev/js/playground.js"></script>
  <script src="../../go.dev/js/godocs.js"></script>
</footer>
</body>
</html>














